<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAPSTONE: Caption Authoring and Photo Sequencing Tool with Ordering, Numbering, and Export</title>
    <!-- jszip.min.js library for TIFF decoding -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- UTIF.js library for TIFF decoding -->
    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.js"></script>
    <style>
        :root {
            --primary: #007acc;
            --primary-dark: #005999;
            --primary-light: #3b82f6;
            --success: #059669;
            --danger: #dc2626;
            --warning: #d97706;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            --border: #e1e5e9;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            background: var(--gray-50);
            height: 100vh;
            overflow: hidden;
            color: var(--gray-900);
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            border-bottom: 1px solid var(--border);
            padding: 15px 20px;
            z-index: 1000;
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: var(--shadow);
        }

        .logo {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-weight: 750;
            font-size: 22px;
            letter-spacing: 0.5px;
            color: var(--gray-900);
            margin-right: 20px;
            flex-shrink: 0;
        }

        @media (max-width: 600px) {
            .logo {
                display: none;
            }
        }

        .story-code-input {
            padding: 6px 14px;
            border: 1.5px solid var(--gray-300);
            border-radius: 8px;
            font-size: 14px;
            min-width: 14ch;
            max-width: 22ch;
            background: white;
            text-align: center;
            transition: all 150ms ease-out;
            color: var(--gray-900);
        }

        .story-code-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0, 122, 204, 0.1);
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 400;
            transition: all 150ms ease-out;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            text-decoration: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        .btn-secondary {
            background: white;
            border: 1.5px solid var(--success);
            color: var(--success);
            box-shadow: var(--shadow-sm);
            padding: 6px 16px;
        }

        .btn-secondary:hover {
            background: var(--success);
            color: white;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger), #b91c1c);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-danger:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        .main-content {
            display: flex;
            width: 100%;
            margin-top: 60px;
            gap: 0;
        }

        .left-panel {
            width: var(--left-width, 40%);
            background: white;
            border-right: 1px solid var(--border);
            overflow-y: auto;
            height: calc(100vh - 60px);
            box-shadow: var(--shadow-sm);
        }

        .right-panel {
            width: var(--right-width, 60%);
            background: white;
            overflow: hidden;
            height: calc(100vh - 60px);
            position: relative;
            box-shadow: var(--shadow-sm);
        }

        .resize-handle {
            width: 6px;
            background: var(--gray-200);
            cursor: col-resize;
            flex-shrink: 0;
            transition: all 150ms ease-out;
            height: calc(100vh - 60px);
            position: relative;
        }

        .resize-handle:hover {
            background: var(--primary);
            box-shadow: 0 0 10px rgba(0, 122, 204, 0.3);
        }

        .resize-handle.dragging {
            background: var(--primary);
            box-shadow: 0 0 10px rgba(0, 122, 204, 0.5);
        }

        .drop-zone {
            border: 2px dashed var(--gray-300);
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin: 20px;
            transition: all 200ms ease-out;
            background: var(--gray-50);
            color: var(--gray-600);
            font-weight: 500;
        }

        .drop-zone.dragover {
            border-color: var(--primary);
            background: rgba(0, 122, 204, 0.05);
            color: var(--primary);
            transform: scale(1.02);
        }

        .image-list {
            padding: 8px 0;
            margin: 0;
            list-style: none;
        }

        .image-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            border-bottom: 1px solid var(--gray-100);
            cursor: grab;
            transition: all 150ms ease-out;
            gap: 15px;
            position: relative;
            background: white;
        }

        .image-item:hover {
            background: var(--gray-50);
            transform: translateX(2px);
            box-shadow: var(--shadow-sm);
        }

        .image-item:last-child {
            border-bottom: none;
        }

        .image-item.dragging {
            opacity: 0.6;
            transform: scale(1.02);
            box-shadow: var(--shadow-lg);
            z-index: 100;
        }

        .image-thumbnail {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--gray-200);
            flex-shrink: 0;
            background: var(--gray-50);
            draggable: false;
            cursor: zoom-in;
            transition: all 150ms ease-out;
            box-shadow: var(--shadow-sm);
        }

        .image-thumbnail:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        .image-info {
            flex: 1;
            min-width: 0;
        }

        .image-filename {
            font-weight: 500;
            font-size: 14px;
            color: var(--gray-900);
            margin-bottom: 4px;
            line-height: 1.2;
        }

        .image-original {
            font-size: 12px;
            color: var(--gray-600);
            font-weight: 400;
            line-height: 1.3;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .drag-handle {
            width: 20px;
            height: 20px;
            background: var(--gray-200);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            font-size: 12px;
            color: var(--gray-500);
            flex-shrink: 0;
            transition: all 150ms ease-out;
        }

        .drag-handle:hover {
            background: var(--gray-300);
            color: var(--gray-700);
        }

        .delete-btn {
            width: 20px;
            height: 20px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 150ms ease-out;
        }

        .delete-btn:hover {
            background: #c82333;
            transform: scale(1.05);
        }

        .edit-suffix-btn {
            width: 20px;
            height: 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 5px;
            transition: all 150ms ease-out;
            flex-shrink: 0;
        }

        .edit-suffix-btn:hover {
            background: #0056b3;
            transform: scale(1.05);
        }

        /* Child image hierarchy styles */
        .child-image {
            margin-left: 20px;
            background-color: #f8f9fa;
            border-left: 3px solid #dee2e6;
        }

        .child-image:hover {
            background-color: #e9ecef;
        }

        .child-indent {
            width: 2px;
            background-color: #adb5bd;
            margin-right: 10px;
            flex-shrink: 0;
        }

        /* Drop zone styling for parent-child relationships */
        .drop-zone-parent {
            border: 2px dashed #007bff !important;
            background-color: rgba(0, 123, 255, 0.15) !important;
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
            transition: all 150ms ease-out;
        }


        @keyframes groupIndicatorFade {
            0% { opacity: 0; transform: scale(0.5); }
            100% { opacity: 1; transform: scale(1); }
        }

        /* Clean drop indicator */
        .drop-indicator {
            height: 2px;
            background: #007bff;
            margin: 2px 0;
            border-radius: 1px;
            transition: all 150ms ease-out;
        }

        /* Thumbnail highlighting during drag */
        .image-thumbnail {
            transition: all 200ms ease-out;
        }

        .drag-target-highlight .image-thumbnail {
            box-shadow: 0 0 0 2px #007bff, 0 0 8px rgba(0, 123, 255, 0.4);
            transform: scale(1.05);
        }


        .editor-container {
            position: relative;
            height: 100%;
        }

        .text-editor {
            width: 100%;
            height: 100%;
            border: none;
            padding: 20px 20px 300px 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 14px;
            line-height: 1.7;
            resize: none;
            outline: none;
            background: transparent;
            color: transparent;
            caret-color: var(--gray-900);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        .editor-display {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px 20px 300px 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 14px;
            line-height: 1.7;
            white-space: pre-wrap;
            word-wrap: break-word;
            pointer-events: none;
            z-index: 1;
            overflow: auto;
            color: var(--gray-900);
        }

        .reference {
            background: rgba(0, 122, 204, 0.1);
            color: var(--primary-dark);
            border-radius: 2px;
        }

        .broken-reference {
            background: rgba(220, 38, 38, 0.1);
            color: var(--danger);
            border-radius: 2px;
        }

        .file-input {
            display: none;
        }

        .add-images-btn {
            background: #28a745;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .add-images-btn:hover {
            background: #218838;
        }

        .empty-state {
            padding: 40px 20px;
            text-align: center;
            color: #666;
        }

        .drop-indicator {
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
            margin: 2px 0;
            border-radius: 2px;
            position: relative;
            z-index: 10;
            box-shadow: 0 0 8px rgba(0, 122, 204, 0.4);
        }

        .left-panel.file-dragover {
            position: relative;
            background: rgba(0, 122, 204, 0.02);
            border-color: var(--primary);
        }

        .lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .lightbox.show {
            display: flex;
        }

        .lightbox-image {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 4px;
        }

        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            cursor: pointer;
            background: none;
            border: none;
        }

        .lightbox-close:hover {
            color: #ccc;
        }

        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 15px 20px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .lightbox-nav:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .lightbox-prev {
            left: 30px;
        }

        .lightbox-next {
            right: 30px;
        }

        .lightbox-counter {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }

        .save-notification {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(40, 167, 69, 0.1);
            color: #28a745;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 10;
        }

        .save-notification.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">CAPSTONE</div>
        <input type="text" class="story-code-input" placeholder="Story code" value="">
        <input type="file" class="file-input" multiple accept="image/*" onchange="handleFileSelect(event)">
        <button class="btn btn-secondary" onclick="document.querySelector('.file-input').click()">Add images</button>
        <button class="btn btn-primary" onclick="exportProject()">Export</button>
        <button class="btn btn-danger" onclick="clearAutoSave()">Clear saved data</button>
    </div>

    <div class="container">
        <div class="main-content">
            <div class="left-panel">
                <div class="drop-zone" id="dropZone">
                    <p>Drop image files here or click "Add images" to select files</p>
                </div>
                <ul class="image-list" id="imageList"></ul>
            </div>
            <div class="resize-handle" id="resizeHandle"></div>
            <div class="right-panel">
                <div class="editor-container">
                    <div class="editor-display" id="editorDisplay"></div>
                    <textarea class="text-editor" id="textEditor" placeholder="Write your captions and design notes here. Use _01, _02, etc. to reference images."></textarea>
                    <div class="save-notification" id="saveNotification">Project saved.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <img class="lightbox-image" id="lightboxImage" alt="">
        <button class="lightbox-close" id="lightboxClose">&times;</button>
        <button class="lightbox-nav lightbox-prev" id="lightboxPrev">‹</button>
        <button class="lightbox-nav lightbox-next" id="lightboxNext">›</button>
        <div class="lightbox-counter" id="lightboxCounter">1 / 1</div>
    </div>

    <script>
        let images = [];
        let imageCounter = 0;
        let draggedItem = null;
        let textReferences = new Map();
        let db = null;
        let autoSaveTimeout = null;
        let isResizing = false;
        let currentLightboxIndex = 0;
        let committedStoryCode = ''; // Track the actually applied story code

        document.addEventListener('DOMContentLoaded', function() {
            setupDropZone();
            setupTextEditor();
            setupImageListDragHandlers();
            setupDynamicInputSizing();
            initIndexedDB();
            setupResizeHandle();
            setupLightbox();
            setupSaveShortcut();
            adjustLayoutForHeader();
            
            // Prevent browser navigation when files are dropped outside designated areas
            document.addEventListener('dragover', e => e.preventDefault());
            document.addEventListener('drop', e => e.preventDefault());
        });

        function adjustLayoutForHeader() {
            const header = document.querySelector('.header');
            const mainContent = document.querySelector('.main-content');
            const leftPanel = document.querySelector('.left-panel');
            const rightPanel = document.querySelector('.right-panel');
            const resizeHandle = document.getElementById('resizeHandle');
            
            const headerHeight = header.offsetHeight;
            mainContent.style.marginTop = headerHeight + 'px';
            leftPanel.style.height = `calc(100vh - ${headerHeight}px)`;
            rightPanel.style.height = `calc(100vh - ${headerHeight}px)`;
            resizeHandle.style.height = `calc(100vh - ${headerHeight}px)`;
        }

        window.addEventListener('resize', adjustLayoutForHeader);

        function setupDropZone() {
            const leftPanel = document.querySelector('.left-panel');
            let dragCounter = 0;
            
            leftPanel.addEventListener('dragenter', (e) => {
                if (e.dataTransfer.types.includes('Files')) {
                    e.dataTransfer.effectAllowed = 'copy';
                    dragCounter++;
                    leftPanel.classList.add('file-dragover');
                    if (images.length === 0) {
                        document.getElementById('dropZone').classList.add('dragover');
                    }
                }
            });

            leftPanel.addEventListener('dragover', (e) => {
                if (e.dataTransfer.types.includes('Files')) {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.dropEffect = 'copy';
                    if (images.length > 0) showFileDropIndicator(e);
                }
            });

            leftPanel.addEventListener('dragleave', (e) => {
                if (e.dataTransfer.types.includes('Files')) {
                    dragCounter--;
                    if (dragCounter === 0) {
                        leftPanel.classList.remove('file-dragover');
                        document.getElementById('dropZone').classList.remove('dragover');
                        const indicator = document.querySelector('.drop-indicator');
                        if (indicator) indicator.remove();
                    }
                }
            });

            leftPanel.addEventListener('drop', (e) => {
                if (e.dataTransfer.types.includes('Files')) {
                    dragCounter = 0;
                    leftPanel.classList.remove('file-dragover');
                    document.getElementById('dropZone').classList.remove('dragover');
                    
                    const indicator = document.querySelector('.drop-indicator');
                    if (indicator) indicator.remove();
                    
                    const files = Array.from(e.dataTransfer.files).filter(file =>
                        file.type.startsWith('image/') ||
                        file.type === 'image/tiff' ||
                        file.name.toLowerCase().endsWith('.tif') ||
                        file.name.toLowerCase().endsWith('.tiff')
                    );
                    if (files.length > 0) {
                        if (images.length === 0) {
                            addImages(files);
                        } else {
                            const position = getDropPosition(e);
                            addImagesAtPosition(files, position);
                        }
                    }
                }
            });

            // Clean up visual state when window regains focus (handles cross-app drag cancellations)
            window.addEventListener('focus', () => {
                dragCounter = 0;
                leftPanel.classList.remove('file-dragover');
                document.getElementById('dropZone').classList.remove('dragover');
                const indicator = document.querySelector('.drop-indicator');
                if (indicator) indicator.remove();
            });
        }

        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            addImages(files);
            event.target.value = '';
        }

        function getDropPosition(e) {
            const imageItems = document.querySelectorAll('.image-item');
            if (imageItems.length === 0) return 0;
            
            const mouseY = e.clientY;
            const firstRect = imageItems[0].getBoundingClientRect();
            if (mouseY < firstRect.top + firstRect.height / 2) return 0;
            
            for (let i = 0; i < imageItems.length; i++) {
                const rect = imageItems[i].getBoundingClientRect();
                if (mouseY < rect.top + rect.height / 2) return i;
            }
            
            return imageItems.length;
        }

        function showFileDropIndicator(e) {
            const existing = document.querySelector('.drop-indicator');
            if (existing) existing.remove();
            
            const imageItems = document.querySelectorAll('.image-item');
            if (imageItems.length === 0) return;
            
            const mouseY = e.clientY;
            for (let i = 0; i < imageItems.length; i++) {
                const rect = imageItems[i].getBoundingClientRect();
                if (mouseY >= rect.top && mouseY <= rect.bottom) {
                    const indicator = document.createElement('div');
                    indicator.className = 'drop-indicator';
                    const itemMiddle = rect.top + rect.height / 2;
                    
                    if (mouseY < itemMiddle) {
                        imageItems[i].parentNode.insertBefore(indicator, imageItems[i]);
                    } else {
                        const nextSibling = imageItems[i].nextSibling;
                        if (nextSibling) {
                            imageItems[i].parentNode.insertBefore(indicator, nextSibling);
                        } else {
                            imageItems[i].parentNode.appendChild(indicator);
                        }
                    }
                    break;
                }
            }
        }

        function addImagesAtPosition(files, position) {
            const newImages = files.map(file => ({
                id: ++imageCounter,
                file: file,
                originalName: file.name,
                fileName: file.name,
                fileType: file.type,
                fileData: null, // Will be set by createThumbnail
                position: 0,
                thumbnailUrl: null,
                parentId: null,
                suffix: ""
            }));
            
            newImages.forEach(img => createThumbnail(img.file, img));
            images.splice(position, 0, ...newImages);
            
            updateFilenames();
            renderImageList();
            updateTextReferencesAfterReorder();
            // Auto-save will happen after thumbnails are created
        }

        function addImages(files) {
            files.forEach(file => {
                const imageObj = {
                    id: ++imageCounter,
                    file: file,
                    originalName: file.name,
                    fileName: file.name,
                    fileType: file.type,
                    fileData: null, // Will be set by createThumbnail
                    position: images.length + 1,
                    thumbnailUrl: null,
                    parentId: null,
                    suffix: ""
                };
                createThumbnail(file, imageObj);
                images.push(imageObj);
            });
            
            updateFilenames();
            renderImageList();
            updateTextReferences();
            // Auto-save will happen after thumbnails are created
        }

        function createThumbnail(file, imageObj) {
            // Store as ArrayBuffer for persistence
            const reader = new FileReader();
            reader.onload = e => {
                imageObj.fileData = e.target.result; // ArrayBuffer
                imageObj.fileName = file.name;
                imageObj.fileType = file.type;

                // Check if this is a TIFF file
                const isTiff = file.type === 'image/tiff' ||
                              file.name.toLowerCase().endsWith('.tif') ||
                              file.name.toLowerCase().endsWith('.tiff');

                if (isTiff && typeof UTIF !== 'undefined') {
                    try {
                        // Decode TIFF using UTIF.js
                        const tiffData = new Uint8Array(e.target.result);
                        const ifds = UTIF.decode(tiffData);
                        UTIF.decodeImage(tiffData, ifds[0]);
                        const rgba = UTIF.toRGBA8(ifds[0]);

                        // Create canvas and draw decoded TIFF data
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = 60;
                        canvas.height = 60;

                        // Create temporary canvas with full image
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = ifds[0].width;
                        tempCanvas.height = ifds[0].height;

                        // Draw RGBA data to temporary canvas
                        const imageData = tempCtx.createImageData(ifds[0].width, ifds[0].height);
                        imageData.data.set(rgba);
                        tempCtx.putImageData(imageData, 0, 0);

                        // Calculate crop area to center the image
                        const aspectRatio = ifds[0].width / ifds[0].height;
                        let sourceX = 0, sourceY = 0, sourceWidth = ifds[0].width, sourceHeight = ifds[0].height;

                        if (aspectRatio > 1) {
                            // Wider than tall - crop sides
                            sourceWidth = ifds[0].height;
                            sourceX = (ifds[0].width - sourceWidth) / 2;
                        } else {
                            // Taller than wide - crop top/bottom
                            sourceHeight = ifds[0].width;
                            sourceY = (ifds[0].height - sourceHeight) / 2;
                        }

                        // Draw cropped image to thumbnail canvas
                        ctx.drawImage(tempCanvas, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, 60, 60);

                        // Convert to optimized data URL
                        imageObj.thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);
                        renderImageList();

                        // Auto-save immediately after thumbnail is ready
                        autoSave();

                    } catch (error) {
                        console.error('TIFF decoding error:', error);
                        // Fall back to standard image processing (will likely fail but gracefully)
                        processStandardImage();
                    }
                } else {
                    // Standard image processing for non-TIFF files
                    processStandardImage();
                }

                function processStandardImage() {
                    const img = new Image();
                    img.onload = () => {
                        // Create canvas for 60x60 thumbnail with proper cropping
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = 60;
                        canvas.height = 60;

                        // Calculate crop area to center the image
                        const aspectRatio = img.width / img.height;
                        let sourceX = 0, sourceY = 0, sourceWidth = img.width, sourceHeight = img.height;

                        if (aspectRatio > 1) {
                            // Wider than tall - crop sides
                            sourceWidth = img.height;
                            sourceX = (img.width - sourceWidth) / 2;
                        } else {
                            // Taller than wide - crop top/bottom
                            sourceHeight = img.width;
                            sourceY = (img.height - sourceHeight) / 2;
                        }

                        // Draw cropped image
                        ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, 60, 60);

                        // Convert to optimized data URL
                        imageObj.thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);
                        renderImageList();

                        // Auto-save immediately after thumbnail is ready
                        autoSave();
                    };

                    img.onerror = () => {
                        console.error('Failed to load image:', file.name);
                        // Create a placeholder thumbnail
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = 60;
                        canvas.height = 60;
                        ctx.fillStyle = '#f0f0f0';
                        ctx.fillRect(0, 0, 60, 60);
                        ctx.fillStyle = '#999';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('?', 30, 35);

                        imageObj.thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);
                        renderImageList();
                        autoSave();
                    };

                    // Create blob URL for the image element
                    const blob = new Blob([e.target.result], {type: file.type});
                    img.src = URL.createObjectURL(blob);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function deleteImage(imageId) {
            const imageToDelete = images.find(img => img.id === imageId);
            if (!imageToDelete) return;

            // If deleting a parent with children, handle children
            if (imageToDelete.parentId === null) {
                const children = getChildImages(imageId);
                if (children.length > 0) {
                    const shouldDeleteChildren = confirm(
                        `This image has ${children.length} child image(s). Delete all children too?\n\n` +
                        `Click OK to delete all, or Cancel to promote children to parent level.`
                    );

                    if (shouldDeleteChildren) {
                        // Delete all children
                        children.forEach(child => {
                            images.splice(images.findIndex(img => img.id === child.id), 1);
                        });
                    } else {
                        // Promote children to parent level
                        children.forEach(child => {
                            child.parentId = null;
                            child.suffix = ""; // Clear suffix when promoting
                        });
                    }
                }

                // Handle text references (only for parent images)
                const deletedPosition = imageToDelete.position;
                const editor = document.getElementById('textEditor');
                const referencePattern = new RegExp(`_${String(deletedPosition).padStart(2, '0')}`, 'g');
                editor.value = editor.value.replace(referencePattern, '!!');
            }

            // Remove the image
            images.splice(images.findIndex(img => img.id === imageId), 1);

            updateFilenames();
            renderImageList();
            updateTextReferencesAfterReorder();
            autoSave();
        }

        function editSuffix(imageId) {
            const image = images.find(img => img.id === imageId);
            if (!image) return;

            const currentSuffix = image.suffix || "";
            // Auto-focus with slight delay
            setTimeout(() => {
                const newSuffix = prompt(`Enter suffix for ${image.originalName}:`, currentSuffix);

                if (newSuffix !== null) {
                // Validate suffix doesn't create duplicate filenames
                if (!validateSuffix(imageId, newSuffix)) {
                    alert("This suffix would create a duplicate filename. Please choose a different suffix.");
                    return;
                }

                // Capture old reference before changing suffix
                const oldReference = `_${String(image.position).padStart(2, '0')}${currentSuffix}`;

                image.suffix = newSuffix;
                updateFilenames();
                renderImageList();

                // Direct replacement for filename change
                const newReference = `_${String(image.position).padStart(2, '0')}${newSuffix}`;
                const editor = document.getElementById('textEditor');
                editor.value = editor.value.replace(
                    new RegExp(oldReference.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
                    newReference
                );

                // Remove edited image from map after direct replacement
                removeImageFromTextReferences(imageId);

                parseAndUpdateReferences();  // Rebuild map after text change
                autoSave();
                }
            }, 50); // Small delay to ensure proper focus
        }

        function validateSuffix(imageId, suffix, targetParentId = null) {
            const image = images.find(img => img.id === imageId);
            if (!image) return false;

            // If targetParentId is provided, check that family; otherwise use current family
            let family;
            if (targetParentId !== null) {
                // Check the target family the image will join
                family = getImageFamily(targetParentId);
            } else {
                // Check current family
                family = getImageFamily(imageId);
            }

            // Check if any other image in the family has the same suffix
            return !family.some(img => img.id !== imageId && img.suffix === suffix);
        }

        function createChildRelationship(draggedId, targetId) {
            const draggedImage = images.find(img => img.id === draggedId);
            const targetImage = images.find(img => img.id === targetId);

            if (!draggedImage || !targetImage || draggedId === targetId) return;

            // Prevent grandchildren - if target is a child, use its parent instead
            const actualParentId = targetImage.parentId || targetId;
            const actualParent = images.find(img => img.id === actualParentId);

            if (!actualParent) return;

            // Get suffix from user with auto-focus
            setTimeout(() => {
                const suffix = prompt(`Enter suffix for ${draggedImage.originalName}:`, "");
                if (suffix === null) return; // User cancelled

                // Validate suffix doesn't create duplicate filenames
                if (!validateSuffix(draggedId, suffix, actualParentId)) {
                    alert("This suffix would create a duplicate filename. Please choose a different suffix.");
                    return;
                }

                // Update image structure
                draggedImage.parentId = actualParentId;
                draggedImage.suffix = suffix;

                // Update filenames (this changes positions)
                updateFilenames();

                // Let systematic approach handle ALL text updates
                updateTextReferencesAfterReorder();
                renderImageList();
                autoSave();
            }, 50); // Small delay to ensure proper focus
        }

        function promoteToParent(childId) {
            const child = images.find(img => img.id === childId);
            if (!child || child.parentId === null) return;

            child.parentId = null;
            child.suffix = "";

            updateFilenames();
            updateTextReferencesAfterReorder();  // Let systematic approach handle text
            renderImageList();
            autoSave();
        }

        function updateFilenames() {
            const storyCode = committedStoryCode;
            const parentImages = getParentImages();

            parentImages.forEach((parent, index) => {
                const basePosition = index + 1;
                const baseName = storyCode ?
                    `${storyCode}_${String(basePosition).padStart(2, '0')}` :
                    `_${String(basePosition).padStart(2, '0')}`;

                parent.filename = baseName + parent.suffix;
                parent.position = basePosition;

                // Handle children
                const children = getChildImages(parent.id);
                children.forEach(child => {
                    child.filename = baseName + child.suffix;
                    child.position = basePosition; // Same as parent
                });
            });
        }

        // Helper functions for parent/child hierarchy
        function getParentImages() {
            return images.filter(img => img.parentId === null);
        }

        function getChildImages(parentId) {
            return images.filter(img => img.parentId === parentId);
        }

        function getImageFamily(imageId) {
            const image = images.find(img => img.id === imageId);
            if (!image) return [];

            if (image.parentId === null) {
                // This is a parent, return it and all children
                return [image, ...getChildImages(imageId)];
            } else {
                // This is a child, return parent and all siblings
                return getImageFamily(image.parentId);
            }
        }

        function renderImageItem(image, isChild) {
            const thumbnailSize = isChild ? 45 : 60;
            const indentClass = isChild ? 'child-image' : '';
            const thumbnailSrc = image.thumbnailUrl || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjBGMEYwIi8+CjxwYXRoIGQ9Ik0yMCAyMEg0MFY0MEgyMFYyMFoiIGZpbGw9IiNDQ0MiLz4KPC9zdmc+';

            return `
                <li class="image-item ${indentClass}" draggable="true" data-id="${image.id}" data-is-child="${isChild}">
                    ${isChild ? '<div class="child-indent"></div>' : ''}
                    <div class="drag-handle">⋮⋮</div>
                    <img class="image-thumbnail" src="${thumbnailSrc}" alt="${image.originalName}"
                         style="width:${thumbnailSize}px;height:${thumbnailSize}px" draggable="false">
                    <div class="image-info">
                        <div class="image-filename">${image.filename}</div>
                        <div class="image-original">${image.originalName}</div>
                    </div>
                    <button class="edit-suffix-btn" onclick="editSuffix(${image.id})" title="Edit suffix">✎</button>
                    <button class="delete-btn" onclick="deleteImage(${image.id})" title="Delete image">×</button>
                </li>
            `;
        }

        function renderImageList() {
            const imageList = document.getElementById('imageList');
            const dropZone = document.getElementById('dropZone');

            if (images.length === 0) {
                imageList.innerHTML = '';
                dropZone.style.display = 'block';
                return;
            }

            dropZone.style.display = 'none';

            const parentImages = getParentImages();
            let html = '';

            parentImages.forEach(parent => {
                html += renderImageItem(parent, false); // false = not child

                const children = getChildImages(parent.id);
                children.forEach(child => {
                    html += renderImageItem(child, true); // true = is child
                });
            });

            imageList.innerHTML = html;

            const thumbnails = imageList.querySelectorAll('.image-thumbnail');
            thumbnails.forEach(thumbnail => {
                thumbnail.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const imageId = parseInt(this.closest('.image-item').dataset.id);
                    openLightbox(imageId);
                });
            });
        }

        function setupImageListDragHandlers() {
            const imageList = document.getElementById('imageList');

            imageList.addEventListener('dragstart', function(e) {
                const imageItem = e.target.closest('.image-item');
                if (!imageItem) return;

                draggedItem = imageItem;
                imageItem.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', imageItem.dataset.id);

                // Highlight only parent images as potential grouping targets
                imageList.querySelectorAll('.image-item').forEach(item => {
                    if (item !== draggedItem && item.dataset.isChild === 'false') {
                        item.classList.add('drag-target-highlight');
                    }
                });
            });

            imageList.addEventListener('dragover', function(e) {
                const imageItem = e.target.closest('.image-item');
                if (!imageItem || imageItem === draggedItem) return;

                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                // Clear existing visual feedback
                const existing = document.querySelector('.drop-indicator');
                if (existing) existing.remove();

                document.querySelectorAll('.drop-zone-parent').forEach(el => {
                    if (el !== imageItem) {
                        el.classList.remove('drop-zone-parent');
                    }
                });

                // Only remove indicator if we're not hovering over the item that has it
                const indicator = document.querySelector('.group-indicator');
                if (indicator && !imageItem.classList.contains('drop-zone-parent')) {
                    indicator.remove();
                }

                const rect = imageItem.getBoundingClientRect();
                const mouseY = e.clientY;
                const itemMiddle = rect.top + rect.height / 2;

                // Only allow grouping on parent images (not children)
                const isParentImage = imageItem.dataset.isChild === 'false';

                // Check if hovering over thumbnail (for parent-child relationship)
                const thumbnail = imageItem.querySelector('.image-thumbnail');
                const thumbnailRect = thumbnail.getBoundingClientRect();
                const hoveringOnThumbnail = isParentImage &&
                                           e.clientX >= thumbnailRect.left &&
                                           e.clientX <= thumbnailRect.right &&
                                           e.clientY >= thumbnailRect.top &&
                                           e.clientY <= thumbnailRect.bottom;

                if (hoveringOnThumbnail) {
                    // Immediately show grouping indicator (no timer)
                    imageItem.classList.add('drop-zone-parent');

                    // Add actual DOM element for grouping indicator
                    let indicator = document.querySelector('.group-indicator');
                    if (!indicator) {
                        const rect = imageItem.getBoundingClientRect();
                        indicator = document.createElement('div');
                        indicator.className = 'group-indicator';
                        indicator.innerHTML = '📎';
                        indicator.style.cssText = `
                            position: fixed;
                            top: ${rect.top + 8}px;
                            left: ${rect.right - 28}px;
                            width: 20px;
                            height: 20px;
                            background: rgba(0, 123, 255, 0.9);
                            color: white;
                            font-size: 12px;
                            font-weight: bold;
                            pointer-events: none;
                            z-index: 100000;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
                            border: 1px solid rgba(255, 255, 255, 0.3);
                            animation: groupIndicatorFade 0.2s ease-out;
                            opacity: 1;
                        `;
                        document.body.appendChild(indicator);
                    } else {
                        // Update position if indicator already exists
                        const rect = imageItem.getBoundingClientRect();
                        indicator.style.top = `${rect.top + 8}px`;
                        indicator.style.left = `${rect.right - 28}px`;
                    }
                } else {
                    // Show clean drop indicator for reordering
                    const indicator = document.createElement('div');
                    indicator.className = 'drop-indicator';

                    if (mouseY < itemMiddle) {
                        imageItem.parentNode.insertBefore(indicator, imageItem);
                    } else {
                        const nextSibling = imageItem.nextSibling;
                        if (nextSibling) {
                            imageItem.parentNode.insertBefore(indicator, nextSibling);
                        } else {
                            imageItem.parentNode.appendChild(indicator);
                        }
                    }
                }
            });

            imageList.addEventListener('drop', function(e) {
                e.preventDefault();

                const imageItem = e.target.closest('.image-item');
                if (!imageItem || !draggedItem || imageItem === draggedItem) {
                    console.log('Drop failed: invalid target or draggedItem');
                    return;
                }

                const draggedId = parseInt(draggedItem.dataset.id);
                const targetId = parseInt(imageItem.dataset.id);

                if (isNaN(draggedId) || isNaN(targetId)) {
                    console.log('Drop failed: invalid IDs', draggedId, targetId);
                    return;
                }

                // Use visual indicator as source of truth for grouping
                const isGroupingOperation = imageItem.classList.contains('drop-zone-parent');

                console.log('Drop operation:', isGroupingOperation ? 'grouping' : 'reordering', 'from', draggedId, 'to', targetId);

                if (isGroupingOperation) {
                    createChildRelationship(draggedId, targetId);
                } else {
                    // Handle reordering logic (including ungrouping)
                    const rect = imageItem.getBoundingClientRect();
                    const mouseY = e.clientY;
                    const itemMiddle = rect.top + rect.height / 2;
                    handleImageReorder(draggedId, targetId, mouseY < itemMiddle);
                }
            });
            
            imageList.addEventListener('dragend', function(e) {
                const imageItem = e.target.closest('.image-item');
                if (imageItem) {
                    imageItem.classList.remove('dragging');
                }

                // Clean up all visual feedback
                document.querySelectorAll('.drop-zone-parent, .drag-target-highlight').forEach(el => {
                    el.classList.remove('drop-zone-parent', 'drag-target-highlight');
                });

                // Remove any group indicators from body
                const indicator = document.querySelector('.group-indicator');
                if (indicator) indicator.remove();

                draggedItem = null;

                const indicators = document.querySelectorAll('.drop-indicator');
                indicators.forEach(indicator => indicator.remove());
            });
        }

        function handleImageReorder(draggedId, targetId, insertBefore) {
            const draggedImage = images.find(img => img.id === draggedId);
            const targetImage = images.find(img => img.id === targetId);

            if (!draggedImage || !targetImage) return;

            // Check if child is being promoted (ungrouped)
            // A child is being promoted if:
            // 1. It's currently a child (has parentId)
            // 2. AND it's being dropped in a reorder operation (drop indicator was shown, not grouping indicator)
            // 3. This works for all cases: dropping on parents, between items, at end of list
            if (draggedImage.parentId !== null) {
                // Child is being reordered (not grouped), so promote to parent
                console.log('Promoting child to parent:', draggedImage.originalName);
                draggedImage.parentId = null;
                draggedImage.suffix = "";  // Clear suffix when promoting to parent
            }

            // If dragging a parent with children, move entire family
            if (draggedImage.parentId === null && getChildImages(draggedId).length > 0) {
                const family = getImageFamily(draggedId);
                const familyIds = family.map(img => img.id);

                // Remove family from current position
                images = images.filter(img => !familyIds.includes(img.id));

                // Find target position
                const targetIndex = images.findIndex(img => img.id === targetId);
                const insertIndex = insertBefore ? targetIndex : targetIndex + 1;

                // Insert family at new position
                images.splice(insertIndex, 0, ...family);
            } else {
                // Handle single image or child movement
                const draggedIndex = images.findIndex(img => img.id === draggedId);
                const targetIndex = images.findIndex(img => img.id === targetId);

                const [movedImage] = images.splice(draggedIndex, 1);
                const newTargetIndex = images.findIndex(img => img.id === targetId);
                const insertIndex = insertBefore ? newTargetIndex : newTargetIndex + 1;

                images.splice(insertIndex, 0, movedImage);
            }

            updateFilenames();
            renderImageList();

            // Let systematic approach handle ALL text updates
            updateTextReferencesAfterReorder();

            autoSave();
        }

        function setupTextEditor() {
            const editor = document.getElementById('textEditor');
            
            editor.addEventListener('input', function() {
                parseAndUpdateReferences();
                autoSave(false);
            });

            editor.addEventListener('scroll', function() {
                document.getElementById('editorDisplay').scrollTop = this.scrollTop;
                document.getElementById('editorDisplay').scrollLeft = this.scrollLeft;
            });
        }

        function parseAndUpdateReferences() {
            const editor = document.getElementById('textEditor');
            const text = editor.value;
            textReferences.clear();
            
            const referencePattern = /_(0[1-9]|\d{2})([A-Za-z0-9_]*)/g;
            let match;

            while ((match = referencePattern.exec(text)) !== null) {
                const refNumber = parseInt(match[1]);
                const suffix = match[2] || '';
                const imageAtPosition = images.find(img =>
                    img.position === refNumber &&
                    (img.suffix || '') === suffix
                );
                if (imageAtPosition) {
                    if (!textReferences.has(imageAtPosition.id)) {
                        textReferences.set(imageAtPosition.id, []);
                    }
                    textReferences.get(imageAtPosition.id).push({
                        start: match.index,
                        end: match.index + match[0].length,
                        originalNumber: refNumber,
                        suffix: suffix
                    });
                }
            }
            
            updateTextDisplay();
        }

        function removeImageFromTextReferences(imageId) {
            textReferences.delete(imageId);
        }

        function updateTextReferencesAfterReorder() {
            const editor = document.getElementById('textEditor');
            let text = editor.value;
            
            const newPositions = new Map();
            images.forEach(img => newPositions.set(img.id, img.position));
            
            const referencePattern = /_(0[1-9]|\d{2})([A-Za-z0-9_]*)/g;
            const newText = text.replace(referencePattern, (match) => {
                const parts = match.match(/_(0[1-9]|\d{2})([A-Za-z0-9_]*)/);
                const oldNumber = parseInt(parts[1]);

                let targetImageId = null;
                const suffix = parts[2] || '';
                for (let [imageId, refs] of textReferences) {
                    if (refs.some(ref => ref.originalNumber === oldNumber && ref.suffix === suffix)) {
                        targetImageId = imageId;
                        break;
                    }
                }

                // Skip references that aren't in the textReferences map
                if (!targetImageId) {
                    return match; // Leave unchanged
                }

                if (newPositions.has(targetImageId)) {
                    const targetImage = images.find(img => img.id === targetImageId);
                    const imageSuffix = targetImage ? targetImage.suffix || '' : '';
                    const newNumber = newPositions.get(targetImageId);
                    return '_' + String(newNumber).padStart(2, '0') + imageSuffix;
                }

                return match;
            });
            
            editor.value = newText;
            parseAndUpdateReferences();
        }

        function updateTextReferences() {
            parseAndUpdateReferences();
        }

        function updateTextDisplay() {
            const editor = document.getElementById('textEditor');
            const display = document.getElementById('editorDisplay');
            let text = editor.value;
            
            let highlightedText = text
                .replace(/_(0[1-9]|\d{2})([A-Za-z0-9_]*)/g, (match) => {
                    const parts = match.match(/_(0[1-9]|\d{2})([A-Za-z0-9_]*)/);
                    const refNum = parseInt(parts[1]);
                    const suffix = parts[2] || '';
                    const imageExists = images.find(img =>
                        img.position === refNum &&
                        (img.suffix || '') === suffix
                    );
                    return imageExists ?
                        '<span class="reference">' + match + '</span>' :
                        '<span class="broken-reference">' + match + '</span>';
                })
                .replace(/!!/g, '<span class="broken-reference">!!</span>');
            
            display.innerHTML = highlightedText;
            display.scrollTop = editor.scrollTop;
            display.scrollLeft = editor.scrollLeft;
        }

        function getTextWithUpdatedReferences() {
            return document.getElementById('textEditor').value;
        }

        function openLightbox(imageId) {
            const imageIndex = images.findIndex(img => img.id === imageId);
            if (imageIndex === -1) return;

            currentLightboxIndex = imageIndex;
            showLightboxImage();
            document.getElementById('lightbox').classList.add('show');
        }

        function showLightboxImage() {
            const image = images[currentLightboxIndex];
            if (!image) return;

            const lightboxImage = document.getElementById('lightboxImage');
            const lightboxCounter = document.getElementById('lightboxCounter');

            // Check if this is a TIFF file
            const isTiff = image.fileType === 'image/tiff' ||
                          image.fileName.toLowerCase().endsWith('.tif') ||
                          image.fileName.toLowerCase().endsWith('.tiff');

            if (isTiff && typeof UTIF !== 'undefined' && image.fileData) {
                try {
                    // Decode TIFF for lightbox display
                    const tiffData = new Uint8Array(image.fileData);
                    const ifds = UTIF.decode(tiffData);
                    UTIF.decodeImage(tiffData, ifds[0]);
                    const rgba = UTIF.toRGBA8(ifds[0]);

                    // Create canvas for full-resolution display
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = ifds[0].width;
                    canvas.height = ifds[0].height;

                    // Draw RGBA data to canvas
                    const imageData = ctx.createImageData(ifds[0].width, ifds[0].height);
                    imageData.data.set(rgba);
                    ctx.putImageData(imageData, 0, 0);

                    // Convert canvas to data URL and set as image source
                    lightboxImage.src = canvas.toDataURL('image/jpeg', 0.9);
                } catch (error) {
                    console.error('TIFF decoding error in lightbox:', error);
                    // Fall back to standard URL (will likely not display properly)
                    const imageUrl = URL.createObjectURL(image.file);
                    lightboxImage.src = imageUrl;
                }
            } else {
                // Standard image display for non-TIFF files
                const imageUrl = URL.createObjectURL(image.file);
                lightboxImage.src = imageUrl;
            }

            lightboxCounter.textContent = `${currentLightboxIndex + 1} / ${images.length}`;
        }

        function showPreviousImage() {
            if (images.length <= 1) return;
            currentLightboxIndex = (currentLightboxIndex - 1 + images.length) % images.length;
            showLightboxImage();
        }

        function showNextImage() {
            if (images.length <= 1) return;
            currentLightboxIndex = (currentLightboxIndex + 1) % images.length;
            showLightboxImage();
        }

        function closeLightbox() {
            document.getElementById('lightbox').classList.remove('show');
        }

        function setupLightbox() {
            const lightbox = document.getElementById('lightbox');
            const lightboxClose = document.getElementById('lightboxClose');
            const lightboxPrev = document.getElementById('lightboxPrev');
            const lightboxNext = document.getElementById('lightboxNext');

            lightboxClose.addEventListener('click', closeLightbox);
            lightboxPrev.addEventListener('click', showPreviousImage);
            lightboxNext.addEventListener('click', showNextImage);

            lightbox.addEventListener('click', function(e) {
                if (e.target === lightbox) closeLightbox();
            });

            document.addEventListener('keydown', function(e) {
                if (!lightbox.classList.contains('show')) return;
                
                if (e.key === 'Escape') {
                    closeLightbox();
                } else if (e.key === 'ArrowLeft') {
                    showPreviousImage();
                } else if (e.key === 'ArrowRight') {
                    showNextImage();
                }
            });
        }

        function exportProject() {
            if (images.length === 0) {
                alert('No images to export');
                return;
            }

            const storyCode = committedStoryCode || 'images';
            const text = getTextWithUpdatedReferences();
            
            let markdown = `# ${storyCode} — Image References\n\n`;
            markdown += text + '\n\n';
            markdown += '## Image List\n\n';
            
            images.forEach(image => {
                markdown += `- ${image.filename} (${image.originalName})\n`;
            });

            const zip = new JSZip();
            zip.file(`${storyCode}_references.md`, markdown);
            
            const validImages = images.filter(img => img.file);
            const imagePromises = validImages.map(image => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const fileExtension = image.originalName.split('.').pop();
                        const newFilename = `${image.filename}.${fileExtension}`;
                        zip.file(newFilename, e.target.result);
                        resolve();
                    };
                    reader.readAsArrayBuffer(image.file);
                });
            });
            
            Promise.all(imagePromises).then(() => {
                return zip.generateAsync({type: 'blob'});
            }).then(function(content) {
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${storyCode}_complete.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`ZIP file ready for download! Contains ${validImages.length} renamed images and markdown references.`);
            });
        }

        function setupResizeHandle() {
            const resizeHandle = document.getElementById('resizeHandle');
            const container = document.querySelector('.main-content');
            
            resizeHandle.addEventListener('mousedown', function(e) {
                isResizing = true;
                resizeHandle.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;
                
                const containerRect = container.getBoundingClientRect();
                const mouseX = e.clientX - containerRect.left;
                const containerWidth = containerRect.width;
                
                let leftPercent = (mouseX / containerWidth) * 100;
                leftPercent = Math.max(20, Math.min(80, leftPercent));
                const rightPercent = 100 - leftPercent;
                
                document.documentElement.style.setProperty('--left-width', leftPercent + '%');
                document.documentElement.style.setProperty('--right-width', rightPercent + '%');
            });
            
            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    resizeHandle.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }

        function initIndexedDB() {
            const request = indexedDB.open('ImageManagerDB', 1);
            
            request.onerror = function(event) {
                console.warn('IndexedDB not available, auto-save disabled');
            };
            
            request.onupgradeneeded = function(event) {
                db = event.target.result;
                const objectStore = db.createObjectStore('projects', { keyPath: 'id' });
                objectStore.createIndex('timestamp', 'timestamp', { unique: false });
            };
            
            request.onsuccess = function(event) {
                db = event.target.result;
                loadAutoSavedProject();
            };
        }

        function autoSave(immediate = true) {
            if (autoSaveTimeout) clearTimeout(autoSaveTimeout);
            
            if (immediate) {
                performSave();
            } else {
                autoSaveTimeout = setTimeout(performSave, 3000);
            }
        }

        // Notification management
        let saveNotificationTimeout = null;
        
        function showSaveNotification() {
            const notification = document.getElementById('saveNotification');
            
            // Clear any existing timeout
            if (saveNotificationTimeout) {
                clearTimeout(saveNotificationTimeout);
            }
            
            // Reset and show notification
            notification.classList.remove('show');
            notification.offsetHeight; // Force reflow
            notification.classList.add('show');
            
            // Set new timeout
            saveNotificationTimeout = setTimeout(() => {
                notification.classList.remove('show');
                saveNotificationTimeout = null;
            }, 2000);
        }

        function performSave() {
            if (!db) return;
            
            const projectData = {
                id: 'autosave',
                timestamp: Date.now(),
                storyCode: document.querySelector('.story-code-input').value,
                text: document.getElementById('textEditor').value,
                images: images.map(img => ({
                    id: img.id,
                    originalName: img.originalName,
                    fileName: img.fileName,
                    fileType: img.fileType,
                    fileData: img.fileData, // ArrayBuffer - serializes properly
                    position: img.position,
                    filename: img.filename,
                    thumbnailUrl: img.thumbnailUrl,
                    parentId: img.parentId,
                    suffix: img.suffix
                })),
                imageCounter: imageCounter
            };
            
            const transaction = db.transaction(['projects'], 'readwrite');
            const objectStore = transaction.objectStore('projects');
            objectStore.put(projectData);
            
            // Show save notification
            showSaveNotification();
        }

        function loadAutoSavedProject() {
            if (!db) return;
            
            const transaction = db.transaction(['projects'], 'readonly');
            const objectStore = transaction.objectStore('projects');
            const request = objectStore.get('autosave');
            
            request.onsuccess = function(event) {
                const savedData = event.target.result;
                if (savedData) {
                    const loadedStoryCode = savedData.storyCode || '';
                    document.querySelector('.story-code-input').value = loadedStoryCode;
                    committedStoryCode = loadedStoryCode; // Update committed value to match loaded data
                    document.getElementById('textEditor').value = savedData.text || '';
                    
                    // Reconstruct File objects from ArrayBuffer data
                    images = (savedData.images || []).map(img => ({
                        ...img,
                        file: img.fileData ? new File([img.fileData], img.fileName, {type: img.fileType}) : null,
                        // Backward compatibility for new fields
                        parentId: img.parentId || null,
                        suffix: img.suffix || ""
                    }));
                    
                    imageCounter = savedData.imageCounter || 0;
                    renderImageList();
                    updateTextReferences();
                }
            };
        }

        function clearAutoSave() {
            if (!db) {
                alert('No saved data to clear');
                return;
            }
            
            if (confirm('This will permanently delete your auto-saved data. Are you sure?')) {
                const transaction = db.transaction(['projects'], 'readwrite');
                const objectStore = transaction.objectStore('projects');
                objectStore.delete('autosave');
                alert("Your saved data has been cleared. If you want to start a new project, refresh the CAPSTONE browser tab now. If you didn't mean to clear your saved data, close this dialog box and save the project again by pressing Ctrl/Cmd+S.");
            }
        }



        function autoResizeInput(input) {
            // Calculate width based on content length plus some padding
            const contentWidth = Math.max(input.value.length + 5, 14);
            input.style.width = Math.min(contentWidth, 22) + 'ch';
        }

        function setupDynamicInputSizing() {
            const storyCodeInput = document.querySelector('.story-code-input');
            
            // Set initial size
            autoResizeInput(storyCodeInput);
            
            // Resize on input
            storyCodeInput.addEventListener('input', function() {
                autoResizeInput(this);
            });
            
            // Commit changes on Enter key
            storyCodeInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    committedStoryCode = this.value;
                    updateFilenames();
                    renderImageList();
                    updateTextReferences();
                    autoSave();
                    this.blur(); // Remove focus after committing
                } else if (e.key === 'Escape') {
                    this.value = committedStoryCode;
                    autoResizeInput(this);
                    this.blur();
                }
            });
            
            // Revert to committed value on blur (click outside)
            storyCodeInput.addEventListener('blur', function() {
                this.value = committedStoryCode;
                autoResizeInput(this);
            });
        }

        function setupSaveShortcut() {
            document.addEventListener('keydown', function(e) {
                if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                    e.preventDefault();
                    autoSave();
                }
            });
        }
    </script>
</body>
</html>